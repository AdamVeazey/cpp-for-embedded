= MISC.
:toc:

Before comparing minor differences between C and {cpp}, it's important to establish common ground on the following key topics before jumping into the rest of the guide.

== {cpp} Is NOT C With Classes
That was indeed the origin and original name of {cpp} between 1979-1982. The early version of {cpp} is comparable pre-C89. {cpp}98 is comparable to C89 in that it was the first  standardized version people used. However, it is so old that code written for C89/{cpp}98 looks outdated when compared to more modern versions of {cpp}. {cpp}11 is similar to C99 in that it's effectively version "1.0" of the language. Both languages have introduced newer standards, with some of the most significant changes occurring recently with C23 and {cpp}20.

This guide focuses on modern {cpp} ({cpp}11 and above), as the embedded systems industry increasingly uses ARM/RISC-V based microcontrollers. Thanks to GCC, you have access to the latest standards in both C and {cpp}.

== Declaration, Definition, Initialization
In both C and {cpp}, functions, types, and variables can be declared, and later possibly defined or initialized. In some cases, declaration and definition/initialization happen simultaneously, while in others, they occur separately.

While reading this guide, pay close attention to the specific terminology—especially between declarations and definitions. They are not interchangeable terms, and this guide uses them with precision.

[source,c++]
----
int foo(int x);             // function declaration
int globalVariable = 10;    // variable declaration & initialization

int foo(int x) {            // function definition
    int y;                  // variable declaration
    y = x * 10;             // variable initialization
    return y;
}

static void bar(int x) {    // function declaration & definition
    return x + 10;
}

struct s;                   // type declaration
struct s {                  // type definition
    int data;
};
----

== Scope
Variables, functions, and types all have an associated scope. Typically, a new scope is introduced when you use `{}`. This applies to functions, if statements, loops, and other blocks of code.

[source,c++]
----
int fileScopeGlobal = 100;

static void fileScopeFunction() {
    int functionScopeA = 50;
    for( int i = 0; i < functionScopeA; ++i ) {
        // 'i' only lives within the scope of this for loop
    }
}

struct MyType {
    // this variable only exists within MyType
    inline static int value = 500; // within {} for MyType definition
};

MyType::value; // specify the scope with MyType::
----

== Optimization and Undefined Behavior

=== TL;DR
Feel free to use `-Os` or other optimization levels. If your code doesn't rely on undefined behavior, the compiler will not "throw out" any logic.

=== Explanation
In both C and {cpp}, the compiler assumes your code contains no undefined behavior (UB). This assumption enables extensive compiler optimizations. Therefore, there is no risk in enabling higher optimization levels (-Os, -O3, etc.) provided your code avoids UB.

You may wonder why certain forms of UB remain undefined—why not just define them? Consider `int`: you might assume it's 32 bits on many platforms. However, not all platforms easily support 32-bit signed two's complement values, which is why the standards committee doesn't enforce this assumption. This means that trying to cast a `int32_t*` to a `int*` is technically undefined behavior, as an `int` and `int32_t` are not guaranteed to be the same.

Prioritizing code clarity over micro-optimizations often leads to better maintainability and less fragile code. Enabling higher levels of optimization usually means that the more readable code has near/exactly zero impact on code size and/or execution speed.

.Example
[source,c++]
----
uint32_t myValue = 0x02;
if( (myValue & (0x1 | 0x2)) == (0x1 | 0x2) ) {
    // both happened
}
else if( myValue & 0x1 ) {
    // left
}
else if( myValue & 0x2 ) {
    // right
}

// vs

bool leftButtonPressed = myValue & 0x01;
bool rightButtonPressed = myValue & 0x02;
if( leftButtonPressed && rightButtonPressed ) {
    // read the line above like a sentence
}
else if( leftButtonPressed ) {
    // read the line above like a sentence
}
else if( rightButtonPressed ) {
    // read the line above like a sentence
}
----

In both examples, no undefined behavior is present. This enables the compiler to apply optimizations confidently. In the second example, where boolean variables capture the results of bitwise operations, the compiler will likely optimize away these variables because they are derived from `myValue` and the operations are straightforward. As a result, depending on the optimization level and the compiler's ability to perform constant folding, the generated machine code may be similar or even identical for both examples.

=== -O0
Even when compiling with no optimizations (`-O0`), the compiler may still perform basic optimizations. These can include basic arithmetic simplifications, dead code elimination, constant folding, inlining of simple functions, and basic common subexpression elimination.
