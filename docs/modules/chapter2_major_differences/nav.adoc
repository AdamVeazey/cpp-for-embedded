* xref:index.adoc[Chapter 2: Major Differences]
** xref:references.adoc[References]
// 12. Reference Types
// C: Only pointers are available for indirect access.
// {cpp}: {cpp} introduces references, which provide a safer and more intuitive way to pass variables by reference.

** xref:namespaces.adoc[Namespaces]
// 9. Namespaces
// C: Namespacing is managed using prefixes or other naming conventions.
// {cpp}: {cpp} introduces namespace to avoid name collisions and organize code.

** xref:overloads.adoc[Overloads]
// 4. Default Arguments in Functions
// C: C does not support default arguments in functions.
// {cpp}: {cpp} allows you to define default values for function parameters, simplifying function calls and reducing overloads.
// {cpp}: Note: binary operator sidetrack discussion

** xref:struct.adoc[Structs]
// C: To use a struct, you need to prefix it with struct unless you use a typedef.
// {cpp}: In {cpp}, the struct keyword is not necessary when using a type, making the code cleaner and more concise.
// 11. Structs and Classes
// C: Structs are purely data structures with no methods or private data.
// {cpp}: {cpp} structs can have member functions, constructors, destructors, and access specifiers (public, private, protected), making them similar to classes.

** xref:enum_type.adoc[Enum Type]
// C: In C, enum constants are treated as int.
// {cpp}: In {cpp}, enum constants have a specific type, which can improve type safety and allow overloading based on the enum type.

** xref:dynamic_memory.adoc[Dynamic Memory]
// 8. New/Delete vs. Malloc/Free
// C: Memory management is done using malloc() and free().
// {cpp}: In {cpp}, new and delete are used for memory management, which also calls constructors and destructors for objects.

** xref:auto.adoc[auto]
// C: auto is an old keyword
// {cpp}: auto is actually used